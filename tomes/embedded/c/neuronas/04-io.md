---
id: "c.stdlib.io"
title: "Input/Output Operations"
category: stdlib
difficulty: intermediate
tags: [c, stdio, fopen, fclose, fprintf, printf, file, stream]
keywords: [fopen, fclose, fread, fwrite, fprintf, printf, stdin, stdout, stderr]
use_cases: [file I/O, command-line I/O, error handling, buffered I/O]
prerequisites: []
related: ["c.stdlib.string"]
next_topics: []
---

# Input/Output Operations

C's stdio.h provides file and console I/O functions.

## File Reading

```c
#include <stdio.h>

int main() {
    FILE* file = fopen("data.txt", "r");
    if (file == NULL) {
        perror("Failed to open file");
        return 1;
    }
    
    char buffer[256];
    
    // Read line by line
    while (fgets(buffer, sizeof(buffer), file) != NULL) {
        printf("Read: %s", buffer);
    }
    
    fclose(file);
    return 0;
}
```

## File Writing

```c
#include <stdio.h>

int main() {
    FILE* file = fopen("output.txt", "w");
    if (file == NULL) {
        perror("Failed to create file");
        return 1;
    }
    
    // Write formatted output
    fprintf(file, "Hello, World!\nValue: %d\n", 42);
    
    fclose(file);
    return 0;
}
```

## Error Handling

```c
#include <stdio.h>

int main() {
    FILE* file = fopen("nonexistent.txt", "r");
    if (file == NULL) {
        // Check errno for error details
        perror("Error opening file");
        return 1;
    }
    
    fclose(file);
    return 0;
}
```

## Standard Streams

```c
#include <stdio.h>

int main() {
    // stdout
    printf("Standard output\n");
    
    // stderr
    fprintf(stderr, "Error output\n");
    
    // stdin (read from user)
    char input[100];
    printf("Enter your name: ");
    if (fgets(input, sizeof(input), stdin) != NULL) {
        printf("Hello, %s", input);
    }
    
    return 0;
}
```

## Binary File Operations

```c
#include <stdio.h>

int main() {
    FILE* file = fopen("binary.dat", "wb");
    if (file == NULL) {
        perror("Failed to create binary file");
        return 1;
    }
    
    int data[] = {1, 2, 3, 4, 5};
    size_t written = fwrite(data, sizeof(int), 5, file);
    
    printf("Wrote %zu integers\n", written);
    
    fclose(file);
    return 0;
}
```

## File Positioning

```c
#include <stdio.h>

int main() {
    FILE* file = fopen("data.txt", "r");
    if (file == NULL) {
        perror("Failed to open file");
        return 1;
    }
    
    // Get current position
    long pos = ftell(file);
    printf("Current position: %ld\n", pos);
    
    // Seek to beginning
    fseek(file, 0, SEEK_SET);
    
    // Read from position
    char buffer[100];
    fgets(buffer, sizeof(buffer), file);
    printf("At beginning: %s", buffer);
    
    fclose(file);
    return 0;
}
```

## Formatted I/O

```c
#include <stdio.h>

int main() {
    int value = 42;
    const char* name = "Alice";
    
    // printf - formatted output
    printf("Name: %s, Value: %d\n", name, value);
    
    // sprintf - format to string
    char buffer[100];
    sprintf(buffer, "Processed: %s, Count: %d", name, value);
    printf("%s\n", buffer);
    
    return 0;
}
```

## File Modes

```c
#include <stdio.h>

int main() {
    // Read mode
    FILE* read_file = fopen("data.txt", "r");
    
    // Write mode (truncates existing file)
    FILE* write_file = fopen("output.txt", "w");
    
    // Append mode
    FILE* append_file = fopen("log.txt", "a");
    
    // Read+write mode
    FILE* rw_file = fopen("config.txt", "w+");
    
    // Binary mode
    FILE* binary_file = fopen("data.bin", "wb");
    
    // Text mode with buffering
    FILE* buffered = fopen("data.txt", "w");
    
    fclose(read_file);
    fclose(write_file);
    fclose(append_file);
    fclose(rw_file);
    fclose(binary_file);
    fclose(buffered);
    
    return 0;
}
```

## Character I/O

```c
#include <stdio.h>
#include <ctype.h>

int main() {
    // fgetc() - read single character
    int ch = fgetc(stdin);
    if (ch != EOF) {
        printf("Character: %c\n", (char)ch);
    }
    
    // fputc() - write single character
    fputc('A', stdout);
    
    // ungetc() - push back character
    ungetc(ch, stdin);
    
    return 0;
}
```

## Common Patterns

### Safe file operations with checks

```c
#include <stdio.h>

void safe_write(const char* filename, const char* content) {
    FILE* file = fopen(filename, "w");
    if (file == NULL) {
        perror("Failed to open file");
        return;
    }
    
    // Write and check for errors
    if (fprintf(file, "%s", content) < 0) {
        perror("Failed to write");
        fclose(file);
        return;
    }
    
    fclose(file);
}
```

### File copy operation

```c
#include <stdio.h>

#define BUFFER_SIZE 4096

void copy_file(const char* src, const char* dst) {
    FILE* src_file = fopen(src, "rb");
    FILE* dst_file = fopen(dst, "wb");
    
    if (src_file == NULL || dst_file == NULL) {
        perror("Failed to open files");
        return;
    }
    
    char buffer[BUFFER_SIZE];
    size_t bytes_read;
    
    while ((bytes_read = fread(buffer, 1, BUFFER_SIZE, src_file)) > 0) {
        fwrite(buffer, 1, bytes_read, dst_file);
    }
    
    fclose(src_file);
    fclose(dst_file);
}
```

### Read line count

```c
#include <stdio.h>

int count_lines(const char* filename) {
    FILE* file = fopen(filename, "r");
    if (file == NULL) return -1;
    
    int count = 0;
    char buffer[1024];
    
    while (fgets(buffer, sizeof(buffer), file) != NULL) {
        count++;
    }
    
    fclose(file);
    return count;
}
```

### Flush output streams

```c
#include <stdio.h>

void ensure_output() {
    // Force write buffer to be flushed
    fflush(stdout);
    fflush(stderr);
}

int main() {
    printf("Message 1\n");
    ensure_output();
    printf("Message 2\n");
    
    return 0;
}
```

### Remove file

```c
#include <stdio.h>

int remove_file(const char* filename) {
    if (remove(filename) == 0) {
        printf("Removed: %s\n", filename);
        return 0;
    } else {
        perror("Failed to remove");
        return -1;
    }
}
```

> **Note**: Always check return values from file operations and use perror() for error reporting. Prefer binary mode for non-text files.
