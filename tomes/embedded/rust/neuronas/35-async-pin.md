---
id: "rust.async.pin"
title: "Pinning"
category: async
difficulty: expert
tags: [rust, async, pin, memory]
keywords: [Pin, Unpin, self-referential]
use_cases: [async internals, self-referential structs]
prerequisites: ["rust.async", "rust.unsafe"]
related: ["rust.async.streams"]
next_topics: []
---

# Pinning

The `Pin<P>` type wraps a pointer `P` and prevents the value pointed to from being moved in memory.

## Why?

Async functions create state machines that may be **self-referential**. Moving them would invalidate internal pointers.

## Unpin

Most types (i32, String, etc.) are `Unpin`, meaning they can be moved safely even when pinned. `Future`s generated by `async` blocks are often `!Unpin`.

```rust
use std::pin::Pin;
use std::future::Future;

fn execute_future(f: Pin<&mut dyn Future<Output = ()>>) {
    // ...
}
```
