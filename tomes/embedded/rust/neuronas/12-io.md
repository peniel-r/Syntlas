---
id: "rust.stdlib.io"
title: "Input/Output"
category: stdlib
difficulty: intermediate
tags: [rust, io, files, std::io]
keywords: [File, BufReader, BufWriter, Read, Write]
use_cases: [file operations, stream processing, buffered I/O]
prerequisites: ["rust.ownership"]
related: ["rust.stdlib.string"]
next_topics: ["rust.stdlib.path"]
---

# Input/Output

Rust's std::io module provides file and stream I/O.

## File Reading

```rust
use std::fs::File;
use std::io::{self, BufRead, BufReader};

fn read_file(path: &str) -> io::Result<String> {
    let file = File::open(path)?;
    let reader = BufReader::new(file);
    let mut lines = String::new();

    for line in reader.lines() {
        lines.push_str(&line?);
        lines.push_str("\n");
    }

    Ok(lines)
}

fn main() -> io::Result<()> {
    let content = read_file("data.txt")?;
    println!("{}", content);
    Ok(())
}
```

## File Writing

```rust
use std::fs::File;
use std::io::{self, BufWriter, Write};

fn write_file(path: &str, content: &str) -> io::Result<()> {
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);
    writer.write_all(content.as_bytes())?;
    writer.flush()?;
    Ok(())
}
```

## Path Operations

```rust
use std::path::Path;

fn main() {
    let path = Path::new("data.txt");

    // Check existence
    if path.exists() {
        println!("File exists");
    }

    // Get parent
    if let Some(parent) = path.parent() {
        println!("Parent: {:?}", parent);
    }

    // Extension
    if let Some(ext) = path.extension() {
        println!("Extension: {:?}", ext);
    }
}
```

## Directory Operations

```rust
use std::fs;

fn main() -> io::Result<()> {
    // Create directory
    fs::create_dir("new_dir")?;

    // List directory contents
    for entry in fs::read_dir(".")? {
        let entry = entry?;
        println!("{:?}", entry.path());
    }

    // Remove directory
    fs::remove_dir("old_dir")?;

    Ok(())
}
```

## Buffered I/O

```rust
use std::io::{BufRead, BufReader, BufWriter, Write};

fn buffered_read(file: &File) -> io::Result<Vec<String>> {
    let reader = BufReader::new(file);
    let mut lines = Vec::new();

    for line in reader.lines() {
        lines.push(line?);
    }

    Ok(lines)
}

fn buffered_write(file: &File, data: &[u8]) -> io::Result<()> {
    let mut writer = BufWriter::new(file);
    writer.write_all(data)?;
    writer.flush()?;
    Ok(())
}
```

## Common Patterns

### Reading entire file

```rust
use std::fs;

fn read_to_string(path: &str) -> io::Result<String> {
    fs::read_to_string(path)
}
```

### Writing with error handling

```rust
use std::io::Write;

fn write_with_fallback(path: &str, data: &str) {
    if let Ok(mut file) = std::fs::File::create(path) {
        if file.write_all(data.as_bytes()).is_err() {
            eprintln!("Failed to write to {}", path);
        }
    }
}
```

### Line by line processing

```rust
use std::io::{BufRead, BufReader};

fn process_lines(path: &str) -> io::Result<()> {
    let file = std::fs::File::open(path)?;
    let reader = BufReader::new(file);

    for line in reader.lines() {
        let line = line?;
        // Process line
        println!("Processing: {}", line);
    }

    Ok(())
}
```

### Directory traversal

```rust
use std::fs;

fn find_files(dir: &str, ext: &str) -> io::Result<Vec<String>> {
    let mut files = Vec::new();

    for entry in fs::read_dir(dir)? {
        let path = entry?.path();
        if path.extension().map_or(false, |e| e == ext) {
            files.push(path.to_string_lossy().to_string());
        }
    }

    Ok(files)
}
```

### Atomic file writes

```rust
use std::fs;

fn atomic_write(path: &str, content: &str) -> io::Result<()> {
    let temp_path = format!("{}.tmp", path);
    fs::write(&temp_path, content)?;
    fs::rename(&temp_path, path)?;
    Ok(())
}
```

> **Tip**: Use BufReader/BufWriter for file I/O to reduce system calls and improve performance.
