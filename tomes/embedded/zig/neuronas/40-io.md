---
id: "zig.stdlib.io"
title: "Input/Output Operations"
category: stdlib
difficulty: intermediate
tags: [zig, io, std.fs, std.net]
keywords: [fs.File, fs.Dir, read, write, print]
use_cases: [file operations, stream processing, standard I/O]
prerequisites: []
related: ["zig.strings"]
next_topics: []
---

# Input/Output Operations

Zig's std.io module provides standard I/O interfaces.

## File Reading

```zig
const std = @import("std");

fn read_file(path: []const u8) !void {
    // Open file for reading
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    // Read into buffer
    var buffer: [1024]u8 = undefined;
    const bytes_read = try file.readAll(&buffer);

    std.debug.print("Read {} bytes\n", .{bytes_read});
}
```

## File Writing

```zig
const std = @import("std");

fn write_file(path: []const u8, content: []const u8) !void {
    // Create new file (or truncate)
    const file = try std.fs.cwd().createFile(path, .{});
    defer file.close();

    // Write content
    const bytes_written = try file.writeAll(content);

    std.debug.print("Wrote {} bytes\n", .{bytes_written});
}
```

## File Appending

```zig
const std = @import("std");

fn append_file(path: []const u8, content: []const u8) !void {
    // Open file for appending
    const file = try std.fs.cwd().openFile(path, .{ .write = true });
    defer file.close();

    // Seek to end and write
    const pos = try file.getEndPos();
    _ = try file.pwrite(content, pos, content.len);
}
```

## Path Operations

```zig
const std = @import("std");

fn path_operations() !void {
    // Build path from components
    const path = try std.fs.path.join(
        &std.heap.page_allocator,
        &[_][]const u8{ "home", "user", "documents"}
    );

    // Get path components
    const dir = path.dirname;
    const filename = path.basename;
    const ext = path.ext;

    std.debug.print("Dir: {s}\n", .{dir});
    std.debug.print("File: {s}\n", .{filename});
    std.debug.print("Ext: {s}\n", .{ext});
}
```

## Directory Operations

```zig
const std = @import("std");

fn directory_operations() !void {
    const cwd = try std.fs.cwd();

    // Create directory
    const new_dir = try cwd.makeOpenPath("new_dir", .{});
    try new_dir.makeDir();

    // List directory contents
    var dir = try cwd.openDir("src", .{ .iterate = true });
    defer dir.close();

    var files = std.ArrayList([]const u8).init(std.heap.page_allocator);
    defer files.deinit();

    while (try dir.next()) |entry| {
        try files.append(try std.fmt.allocPrint(
            std.heap.page_allocator,
            "{s}",
            .{entry.name}
        ));
    }

    std.debug.print("Files: {any}\n", .{files.items});
}
```

## Stdin Reading

```zig
const std = @import("std");

fn read_stdin() !void {
    const stdin = std.io.getStdIn();

    // Read all input until EOF
    const input = try stdin.readAllAlloc(std.heap.page_allocator);
    defer std.heap.page_allocator.free(input);

    std.debug.print("Input: {s}\n", .{input});
}
```

## Stdout Writing

```zig
const std = @import("std");

fn write_stdout(text: []const u8) !void {
    const stdout = std.io.getStdOut();
    try stdout.writeAll(text);
}
```

## Buffered I/O

```zig
const std = @import("std");

fn buffered_io_example() !void {
    const file = try std.fs.cwd().createFile("buffered.txt", .{});
    defer file.close();

    const reader = file.reader();
    const writer = file.writer();

    // Buffered reader (8KB buffer)
    var buf_reader = std.io.bufferedReaderSize(reader, 8192);

    // Read with buffer
    var buffer: [8192]u8 = undefined;
    const bytes_read = try buf_reader.read(&buffer);

    // Buffered writer
    var buf_writer = std.io.bufferedWriterSize(writer, 8192);

    try buf_writer.writeAll(buffer[0..bytes_read]);
    try buf_writer.flush();

    std.debug.print("Buffered read/write: {} bytes\n", .{bytes_read});
}
```

## Common Patterns

### Line-by-line file processing

```zig
const std = @import("std");

fn process_lines(path: []const u8) !void {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const reader = file.reader();
    var buf_reader = std.io.bufferedReader(reader);

    var line_num: usize = 0;
    var buf: [1024]u8 = undefined;

    while (true) {
        const bytes_read = try buf_reader.read(&buffer);
        if (bytes_read == 0) break;

        // Process line (simplified)
        const line = buffer[0..bytes_read];
        std.debug.print("Line {}: {s}\n", .{line_num, line});
        
        line_num += 1;
    }
}
```

### Atomic file writes

```zig
const std = @import("std");

fn atomic_write(path: []const u8, content: []const u8) !void {
    // Write to temp file then rename for atomicity
    const temp_path = try std.fs.path.join(&std.heap.page_allocator, &[_][]const u8{ path, ".tmp" });
    
    try std.fs.cwd().writeFile(.{ .path = temp_path }, content);
    try std.fs.cwd().rename(temp_path, path);
}
```

### File existence check

```zig
const std = @import("std");

fn check_file_exists(path: []const u8) bool {
    // Check if file exists
    const file_exists = std.fs.cwd().openFile(path, .{ .mode = .read_only })
        catch |err| switch (err) {
            error.FileNotFound => false,
            else => true,
        };
    
    return file_exists;
}
```

### Remove file or directory

```zig
const std = @import("std");

fn remove_path(path: []const u8) !void {
    // Remove file
    if (check_file_exists(path)) {
        try std.fs.cwd().deleteFile(path);
    } else {
        // Try removing directory
        std.fs.cwd().deleteTree(path) catch |err| {
            std.debug.print("Delete error: {}\n", .{err});
        };
    }
}
```

### Streaming large files

```zig
const std = @import("std");

fn stream_large_file(path: []const u8, chunk_size: usize) !void {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const reader = file.reader();
    var buffer: [chunk_size]u8 = undefined;
    var total_read: usize = 0;

    while (true) {
        const bytes_read = try reader.read(&buffer);
        if (bytes_read == 0) break;
        
        total_read += bytes_read;
        
        // Process chunk
        process_chunk(buffer[0..bytes_read]);
    }
}

fn process_chunk(chunk: []u8) void {
    // Process chunk of data
    _ = chunk;  // Placeholder
}
```

### Copy file

```zig
const std = @import("std");

fn copy_file(src: []const u8, dst: []const u8) !void {
    const src_file = try std.fs.cwd().openFile(src, .{});
    defer src_file.close();

    const dst_file = try std.fs.cwd().createFile(dst, .{});
    defer dst_file.close();

    // Copy in chunks
    var buffer: [65536]u8 = undefined;
    var total_copied: usize = 0;

    while (true) {
        const bytes_read = try src_file.read(&buffer);
        if (bytes_read == 0) break;

        const bytes_written = try dst_file.writeAll(buffer[0..bytes_read]);
        total_copied += bytes_written;
    }
}
```

> **Tip**: Use buffered I/O for better performance. Use `std.io.bufferedReader` and `std.io.bufferedWriter` for buffered operations.
